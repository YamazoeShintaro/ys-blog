{
    "version": "https://jsonfeed.org/version/1",
    "title": "YS_blog",
    "home_page_url": "https://http://localhost:3000/",
    "feed_url": "https://http://localhost:3000/rss/json",
    "description": "Zennに投稿したプログラミング技術に関する記事をこちらにも連携させて投稿します。",
    "icon": "https://http://localhost:3000/favicon/favicon.ico",
    "author": {
        "name": "YS"
    },
    "items": [
        {
            "id": "https://http://localhost:3000/posts/javascript",
            "content_html": "\n## 最初に\n\n関数を並べて作成するスクリプトを書きながら限界を感じたので、オブジェクト指向について勉強して複雑なプログラムも綺麗にかつ簡単に作成したいと思う。\n\n個人的に思うのは難しい技術ほど最初は取っ付きにくいがプログラムが複雑になるにつれて、その恩恵が大きくなると考えている。\n\n関数を並べるだけのプログラムは最初は簡単で取っ付きやすいがプログラムが大きくなるに連れて状態管理等が必要になり苦しくなってくると思う。最初に苦労して後で楽するか、最初に楽をして苦労するかだと思う。その辺を考慮しながら、技術選定をするのは結構重要な考え方な気がする。\n\n## シンボルプロパティ\n\n`symbol()` を使って作成されたデータは6種類ある（文字列、数値、BigInt、真偽値、undefined、シンボル）プリミティブデータ型と呼ばれるものの一つであり、シンボルと呼ばれている。\n\nすべてのプリミティブ値は、イミュータブルimmutable（変更出来ない値を指す）で変更できません。\n\n下記ではオブジェクトの列挙方法をいくつか紹介しながら、シンボルプロパティの動作を確認していく。\n\n使い方\n\n```jsx\n// シンボルから返される値は一意である。\nlet sym1 = Symbol()\nlet sym2 = Symbol("foo")\nlet sym3 = Symbol("foo")\n\nSymbol("foo") === Symbol("foo")  // false\n```\n\n```jsx\nconst SYM = Symbol()\nconst o = {a: 1, b:2, c:3, [SYM]: 4}\nfor (let prop in o) {\n  // for inはfor ofと違い順番が担保されてないので最初にどれが来るか予測出来ない。\n  if(!o.hasOwnProperty(prop)) continue\n  console.log(`${prop}: ${o[prop]}`)\n}\n\n// 実行結果\na: 1\nb: 2\nc: 3\n```\n\n実際には `if(!o.hasOwnProperty(prop)) continue` は省略できる。\n\nしかし `for...in` を使用する際は `if(!o.hasOwnProperty(prop)) continue` を使うことを習慣づけておいた方が良い。 `in` がプロトタイプチェーンを遡ってプロパティを列挙\n\nオブジェクトは「継承」によってプロパティを持つ場合があるので\n\n### for...in, for...of違い\n\nfor...inは主にオブジェクトのループ専用として使われる。変数に入るのはオブジェクトのキーで順番は通りではない。値を取り出したい場合は変数に入った値を使用する。\n\n一応、配列にも使用出来て、その場合は変数にindex番号が入る。 `0, 1, 2, 3` のような値が入る。ただ順序を保証していないので配列のループには不向きである。\n\nそして下記のような使いにくい場面もある。\n\nこれは `in` がプロトタイプチェーンを遡るためである。\n\n個人的にはなぜこんな仕様になっているのか不思議だ、オブジェクトにないプロパティまで出力するせいで使いにくい。\n\n[in と hasOwnProperty() の違い - Qiita](https://qiita.com/shuhei/items/dabf0ca097f05264baf9)\n\n```jsx\nObject.prototype.hoge = "hogeValue";\nArray.prototype.fuga = "fugaValue";\n\nconst obj = {key1: "value1", key2: "value2", key3: "value3"};\n\nfor(let o in obj) {\n    console.log(o);\n}\n\nconst array = ["value1", "value2", "value3"];\n\nfor(let a in array) {\n    console.log(a);\n}\n\n// 実行結果\nkey1 \nkey2 \nkey3 \nhoge // 拡張で追加したhogeプロパティまで出力されている\n0 \n1 \n2 \nfuga // arrayも同様に\nhoge // そしてObjectで追加したhogeプロパティはarrayに継承されるので出力される\n```\n\nこれを回避する方法がある。\n\n`obj.hasOwnProperty(o)` を使用してobj自体がoプロパティを持っているか確認してあれば `True` を返す。 \n\n※プロパティはkeyと値が対になったものを指す \n\nプロパティ\n`{key: value}`\nこれが複数にあるのをオブジェクト\n\nオブジェクト\n`{key: value, key2: value2...}`\n\n`obj.hasOwnProperty(o)` はプロトタイプチェーンまで遡ることはないので `hoge`, `fuga` で `True` になる事はない。\n\n```jsx\nObject.prototype.hoge = "hogeValue";\nArray.prototype.fuga = "fugaValue";\n\nconst obj = {key1: "value1", key2: "value2", key3: "value3"};\n\nfor(let o in obj) {\n    if (obj.hasOwnProperty(o)) {\n        console.log(o);\n    }\n}\n\nconst array = ["value1", "value2", "value3"];\n\nfor(let a in array) {\n    if (array.hasOwnProperty(a)) {\n        console.log(a);\n    }\n}\n\n// 実行結果\nkey1\nkey2\nkey3\n0\n1\n2\n```\n\nもう一つは `defineProperty` を使用すると `prototype` の汚染を回避する事ができる。\n\n[prototype汚染しないようにObject.prototypeを拡張する - Qiita](https://qiita.com/kakusuke/items/d4f7f3d45f85eaef6fda)\n\n### イミュータブル とconst違い\n\n```jsx\nconst obj = {foo: 0}; // constである変数を作る\nobj.foo = 42; // {foo: 0}はミュータブルなのでfooを変更できる\nobj = {bar: 0}; // error! objへ再代入はできない！\n\nlet immutableObj = new Immutable({foo: 0}); // Immutableオブジェクトを生成してimmutableObjへ代入する。イミュータブルなオブジェクトはImmutable.jsなどのライブラリで生成できます\nimmutableObj.set("foo", 42); // immutableオブジェクトは変更できない\nimmutableObj.get("foo"); // fooは42ではなく0のまま\nimmutableObj = immutableObj.set("foo", 42); // 再代入することで変更できる\n```\n\n## Object.keys\n\nオブジェクトのプロパティにあるkeyを配列で取得する事ができる。\n\nこれを使ってオブジェクトを列挙する事ができる。\n\n```jsx\nconst SYM = Symbol()\nconst o = {a: 1, b: 2, c: 3, [SYM]: 4}\nconst propArray = Object.keys(o)\n\npropArray.forEach(prop => console.log(`${prop}: ${o[prop]}`))\n\n// 実行結果\na: 1\nb: 2\nc: 3\n\n```\n\n## クラスとインスタンス生成\n\n```jsx\nclass Car {\n  constructor() {\n  }\n}\n\nconst car1 = new Car()\nconst car2 = new Car()\n\nconsole.log(car1 instanceof Car) // true\nconsole.log(car2 instanceof Car) // true\nconsole.log(car1 instanceof Array) // false\n```\n\n### メソッドを追加してみる\n\nシフトを変更するメソッドを追加する。エラー文を挟む事で無効なギアが設定出来ないようにしている。\n\n```jsx\nclass Car {\n  constructor(make, model) {\n    this.make = make\n    this.model = model\n    this.userGears = ["P", "N", "R", "D"]\n    this.userGear = this.userGears[0]\n  }\n  shift(gear) {\n    if(this.userGears.indexOf(gear) < 0)\n      throw new Error(`ギヤ指定が正しくない: ${gear}`)\n    this.userGear = gear\n  }\n}\n\nconst car1 = new Car(\"Tesla\", \"Model S\")\nconsole.log(car1)\nconsole.log(car1.make)\n\nconst car２ = new Car(\"Mazda\", \"3i\")\nconsole.log(car2)\nconsole.log(car2.make)\n```\n\n上記の状態ではメソッドを使用しなくても `car1.userGear = "X"` で変更可能となっており、アクセス制御がなく予期しないデータの変更をされてしまう可能性があり良くない。それを解決する方法として「アクセスプロパティ」を利用する。 `get, set` をセットで使用する。後で詳しくみていく。今はこれらがメンバ変数を操作してるという理解で大丈夫だと思う。 `_` を変数の前に付けるだけでこれが `get, set` 以外で直接参照されているのはおかしい事を教えてくれるに過ぎず機能を制限出来るわけでない事に注意が必要である。\n\n```jsx\nclass Car {\n  constructor(make, model) {\n    this.make = make\n    this.model = model\n    this._userGears = ["P", "N", "R", "D"]\n    this._userGear = this._userGears[0]\n  }\n  get userGear() { return this._userGear; }\n  set userGear(value) {\n    if(this.userGears.indexOf(gear) < 0)\n      throw new Error(`ギヤ指定が正しくない: ${gear}`)\n    this.userGear = gear\n      \n  }\n  \n  shift(gear) { this.userGear = gear; }\n}\n\nconst car1 = new Car(\"Tesla\", \"Model S\")\nconsole.log(car1)\nconsole.log(car1.userGear)\n\n// 実行結果\nCar {\n  make: "Tesla",\n  model: "Model S",\n  _userGears: [ "P", "N", "R", "D" ],\n  _userGear: "P"\n}\nP\n```\n\nこれを防ぐ方法として WeekMapを使用した関数をクロージャに隠す事で外から関数内の変数にアクセスして直接値を変更する事を防ぐ事が出来る。\n\n```jsx\nconst Car =  (function() {\n  const carProps = new WeakMap();\n  class Car {\n\t  constructor(make, model) {\n      this.make = make\n      this.model = model\n      this._userGears = ["P", "N", "R", "D"]\n      carProps.set(this, { userGear: this._userGears[0] })\n    }\n    get userGear() { return carProps.get(this).userGear; }\n    set userGear(value) {\n      if(this._userGears.indexOf(value) < 0)\n        throw new Error(`ギヤ指定が正しくない: ${value}`)\n      carProps.get(this).userGear = value;\n    }\n\n    shift(gear) { this.userGear = gear; }\n  }\n  return Car;\n})();\nconst car1 = new Car(\"Tesla\", \"Model S\")\nconsole.log(car1)\n\n// 実行結果\nCar {make: "Tesla", model: "Model S", _userGears: Array(4)}make: \"Tesla\"model: \"Model S\"_userGears: (4) ["P", "N", "R", "D"]userGear: (...)[[Prototype]]: Object\n```\n\n外からは `car1.userGear = "R"` で値を変更出来なくなる。\n\n## プロトタイプ\n\nJavaScriptはインスタンス（Classをnewして生成されたオブジェクト）に対して使えるメソッドを参照するとき、プロトタイプメソッドを参照している。 `Car.prototype.shift` のように書かれる。 同様にArrayの関数はforEachは `Array.prototype.forEach` と書かれる。普段はこのような書き方ではなく `array.forEach((a) => {a})` みたいな感じで間が省略されている。他にも `#` を使って表すことも出来る。 `Car#shift` と書く事も出来る。\n\nプロトタイプはクラスメソッドのみでなく、通常の関数もprototypeと呼ばれる特別なプロパティを持っている。関数の場合はあまり意識しなくて良さそう。\n\nプロトタイプで重要なのは「動的ディスパッチ」というメカニズムでオブジェクトのプロパティ（メソッド）にアクセスしてそれが存在しない場合、そこでエラーを直ぐに返すのではなく、そのオブジェクトのプロトタイプを見て同じプロパティがないか確認する。例クラスCarが生成したインスタンスは全て同じプロトタイプを共有してるから、同じメソッドが使用できるという当たり前の事を小難しく言っている。\n\nではなんのために動的ディスパッチを出したのかと言うと、インスタンスを生成した後にそのインスタンスに同じ名前の関数を定義する事でプロトタイプにあるメソッドをそのインスタンスのみだが上書きして変更する事が可能である説明のために少しだけ登場させた。\n\n実際にインスタンスに直接メソッドを定義してプロトタイプチェーンを上書きしたのが下記のコードになる。\n\n```jsx\nconst Car =  (function() {\n  const carProps = new WeakMap();\n  class Car {\n    constructor(make, model) {\n      this.make = make\n      this.model = model\n      this._userGears = ["P", "N", "R", "D"]\n      carProps.set(this, { userGear: this._userGears[0] })\n    }\n    get userGear() { return carProps.get(this).userGear; }\n    set userGear(value) {\n      if(this._userGears.indexOf(value) < 0)\n        throw new Error(`ギヤ指定が正しくない: ${value}`)\n      carProps.get(this).userGear = value;\n    }\n    shift(gear) { this.userGear = gear; }\n  }\n  return Car;\n})();\n\nconst car1 = new Car()\nconst car2 = new Car()\nconsole.log(car1.shift === Car.prototype.shift)\nconsole.log(car1.shift === car2.shift)\ncar1.shift("D")\nconsole.log(car1.userGear)\n\n// メソッドを小文字でも大文字に変換するように上書きした\ncar1.shift = function(gear) { this.userGear = gear.toUpperCase() }\n// インスタンスに直接定義したものだから、prototypeメソッド\n// ではないと出力される。\nconsole.log(car1.shift === Car.prototype.shift)\nconsole.log(car1.shift === car2.shift)\ncar1.shift("d")\nconsole.log(car1.userGear)\n\n// 実行結果\ntrue\ntrue\nD\nfalse\nfalse\nD\n```\n\n## 静的メソッド\n\nインスタンスに関わらない処理を行う際に使用されるらしい。ただ普通のメソッドとと動作が違うのかよく分からない。試しに `static` を外して `this.nextVin++` とクラスメソッドの様に変更しても動作は一緒になる。ただ下の `areSimilar, areSame` はクラスから直接呼び出しているので通常のメソッド定義だと実行出来なくなるので、少なくとも静的メソッドを使用する意味はありそうだ。個人的に感心したのは `Car.nextVin = 0` この行でインスタンス間で共有する変数を持たせることができるのに驚いた。\n\nこれは状態を持たせるの使える気がする。関数のみでやってた際は状態を管理するのが大変だったのでこれはとても使えそうな気がする。\n\n```jsx\nclass Car {\n    static getNextVin() {\n        return Car.nextVin++\n    }\n    constructor(make, model) {\n        this.make = make\n        this.model = model\n        this.vin = Car.getNextVin()\n    }\n    static areSimilar(car1, car2) {\n        return car1.make === car2.make && car1.model === car2.model\n    }\n\n    static areSame(car1, car2) {\n        return car1.vin === car2.vin\n    }\n}\n\n// オブジェクトとして持たせる事ができる。\n// しかもこの値はクラス間で共有できる。\n// 状態管理に使える。\nCar.nextVin = 0\nCar.nextVin1 = {\"hi\": 0}\n\nconst car1 = new Car(\"Tesla\", \"Model S\")\nconst car2 = new Car(\"Mazda\", \"3i\")\nconst car3 = new Car(\"Mazda\", \"3i\")\n\nconsole.log(car1.vin)\nconsole.log(car2.vin)\nconsole.log(car3.vin)\n\nconsole.log(Car)\n```\n\n## 継承\n\nクラスを継承して下位のクラスにメソッドを追加する。\n\n```jsx\nclass Vehicle {\n    constructor() {\n        this.passengers = []\n        console.log(\"Vehicleが生成された\")\n    }\n    addPassenger(p) {\n        this.passengers.push(p)\n    }\n}\n\nclass Car extends Vehicle {\n    constructor() {\n        super()\n        console.log(\"Carが生成された\")\n    }\n    depoyAirbags() {\n        console.log(\"バーンッ!\")\n    }\n}\n\nconst v = new Vehicle()\nv.addPassenger(\"太郎\")\nv.addPassenger(\"花子\")\nconsole.log(v.passengers)\n// v.depoyAirbags() エラーになる\n\nconst c = new Car()\nc.addPassenger(\"恵子\")\nc.addPassenger(\"順子\")\n\nconsole.log(c.passengers)\nc.depoyAirbags()\n\n```\n\n## ポリモーフィズム\n\nあるインスタンスをそのインスタンスが属するクラスのメンバーとして扱うだけではなく、スーパクラスのメンバーとして扱う。おそらく下記のコードから推測するに継承先のクラスでもある事を言いたいだけだと思う。インスタンス `c` は `Car` のクラスメンバに属するし `Vehicle` のクラスメンバにも属する。それだけの事を小難しく言っている。\n\n```jsx\nclass Vehicle {\n    constructor() {\n        this.passengers = []\n        console.log(\"Vehicleが生成された\")\n    }\n    addPassenger(p) {\n        this.passengers.push(p)\n    }\n}\n\nclass Car extends Vehicle {\n    constructor() {\n        super()\n        console.log(\"Carが生成された\")\n    }\n    depoyAirbags() {\n        console.log(\"バーンッ!\")\n    }\n}\n\nclass Mortrcycle extends Vehicle {}\n\nconst v = new Vehicle()\nv.addPassenger(\"太郎\")\nv.addPassenger(\"花子\")\n\nconst c = new Car()\nc.addPassenger(\"恵子\")\nc.addPassenger(\"順子\")\n\nconsole.log(c.passengers)\nc.depoyAirbags()\n\nconst c2 = new Car()\nconst m = new Mortrcycle()\n\nconsole.log(c instanceof Car)\nconsole.log(c instanceof Vehicle)\nconsole.log(m instanceof Car)\nconsole.log(m instanceof Mortrcycle)\nconsole.log(m instanceof Vehicle)\n\nconsole.log(c instanceof Object)\n// 文字列もObjectを継承してるのか気になった。\n// ただの文字列の場合はStringオブジェクトを継承しない。\n// const s = \"hrl\"\nconst s = new String(\"hrl\");\nconsole.log(s instanceof Object)\n// Strring オブジェクトも継承してない...\nconsole.log(s instanceof String)\nconsole.log(typeof s)\nconsole.log(s.valueOf())\nconsole.log(s instanceof Object)\n```\n\n## プロパティの列挙再び\n\nプロトタイプチェーン上にあるプロパティにも `for...in` がアクセスしてしまう事を確認する。\n\n```jsx\nclass Super {\n    constructor() {\n        this.name = "Super"\n        this.isSuper = true\n    }\n}\n\nSuper.prototype.sneaky = "非推奨!"\n\nclass Sub extends Super {\n    constructor() {\n        super()\n        this.name = "Sub"\n        this.isSub = true\n    }\n}\n\nconst obj = new Sub()\n\nfor(let p in obj) {\n    console.log(`${p}: ${obj[p]}` + \n                (obj.hasOwnProperty(p)? "" : " (継承)"))\n}\n```\n\n## 多重継承、ミックスイン、インタフェース\n\nオブジェクト指向では「多重継承」と呼ばれる機構をサポートしている。\n\nあるクラスが複数のスーパクラスを継承している状態である。これはメソッド名の衝突などを起こす危険性があり、その場合どちらを優先するのかも不明である。そのため多くの言語では多重継承を許していない。\n\nしかし世の中の問題を考えた場合、多重継承が自然な場面も見られる。車は乗り物で保険をかけられる。さらに家は乗り物ではないが、保険をかけられる。こうしたケースにも対応できるように「インタフェース」と言う機構が用意されている。 `Car` クラスはスーパクラスとして `Vehicle` しか継承出来ないけれど、複数のインタフェース（ `Insurable`, `Container` ）を持つことができる。\n\nJavaScriptでは「ミックスイン」と言う概念が使われており、それを使用する事で多重継承の問題を解決することができる。\n\n下記は上手く動作するが、インスタンスを作成するたびにそれを `makeInsurable` 関数に渡さなければならないのが冗長である。\n\n```jsx\nclass Car {\n    constructor() {\n        \n    }\n}\n\nclass InsurancePolicy {}\n\nfunction makeInsurable(o) {\n    o.addInsurancePolicy = function(p) { this.insurancePolicy = p }\n    o.getInsurancePolicy = function() { return this.insurancePolicy }\n    o.isInsured = function() { return !!this.insurancePolicy }\n}\n\n// makeInsurable(Car) とCarクラスに保険機能を追加しようとするとエラーになる\n// const car1 = new Car()\n// car1.addInsurancePolicy(new InsurancePolicy())\n\nconst car1 = new Car()\nmakeInsurable(car1)\nconsole.log(car1.isInsured())\ncar1.addInsurancePolicy(new InsurancePolicy())\nconsole.log(car1.isInsured())\n```\n\nこれを解決するのに Carクラスのプロトタイプを渡してそこに `makeInsurable` のメソッドを追加する。\n\n```jsx\nmakeInsurable(Car.prototype)\n\nconst car1 = new Car()\nconsole.log(car1.isInsured())\ncar1.addInsurancePolicy(new InsurancePolicy())\nconsole.log(car1.isInsured())\n```\n\nこれで新しく作成したメソッドがいつもクラスCarの一部であるかのごとく動作する。JavaScriptから見るとこのメソッドはクラスCarの一部になる。コード上ではCarと保険に関する機能は分割されているので個別で管理する事ができる。ただ保険担当グループが `shift` メソッドを作成したりし始めたりすると衝突を起こすので注意が必要である。そして保険を掛けられるオブジェクトのに抽出したい場合 `instanceOf` をしてもCarクラスとしてしか認識されないので不便になることがある。\n\nシンボルを使用するとCar機能と保険機能の衝突を防ぐ事ができる。\n\n```jsx\nclass Car {\n    constructor() {\n    }\n}\n\nclass InsurancePolicy {}\n\nconst ADD_POLICY = Symbol()\nconst GET_POLICY = Symbol()\nconst IS_INSURED = Symbol()\nconst _POLICY = Symbol()\n\nfunction makeInsurable(o) {\n    o[ADD_POLICY] = function(p) { this.insurancePolicy = p }\n    o[GET_POLICY] = function() { return this.insurancePolicy }\n    o[IS_INSURED] = function() { return !!this.insurancePolicy }\n}\n\n// makeInsurable(Car) とCarクラスに保険機能を追加しようとするとエラーになる\n// const car1 = new Car()\n// car1.addInsurancePolicy(new InsurancePolicy())\n\nconst car1 = new Car()\nmakeInsurable(car1)\nconsole.log(car1[IS_INSURED]())\ncar1[ADD_POLICY](new InsurancePolicy())\nconsole.log(car1[IS_INSURED]())\n```\n",
            "url": "https://http://localhost:3000/posts/javascript",
            "title": "JavaScriptでオブジェクト指向の概要を掴む",
            "summary": "関数を並べて作成するスクリプトを書きながら限界を感じたので、オブジェクト指向について勉強して複雑なプログラムも綺麗にかつ簡単に作成したいと思う。個人的に思うのは難しい技術ほど最初は取っ付きにくいがプログラムが複雑になるにつれて、その恩恵が大きくなると考えてい...",
            "date_modified": "2021-10-30T15:00:00.000Z"
        }
    ]
}